var p = new WeakMap();

export default class CustomHTMLMediaElementImpl {
  get error() {
    // Since MediaError is not constructible, we're kind of screwed. We could re-implement it I guess.
  }

  get srcObject() {}
  set srcObject(v) {}

  get currentSrc() {
    return p(this).currentSrc;
  }

  get networkState() {
    return p(this).networkState;
  }

  // TODO: technically reflected, but "limited only to known values". Would be
  // better to get this autogenerated
  get preload() {}
  set preload(v) {}

  get buffered() {
    // Screwed since TimeRanges is not constructible.
  }

  get readyState() {
    return p(this).readyState;
  }

  get seeking() {
    return p(this).seeking;
  }

  get currentTime() {}
  set currentTime(v) {}

  get duration() {
    return p(this).duration;
  }

  get paused() {
    return p(this).paused;
  }

  get defaultPlaybackRate() {}
  set defaultPlaybackRate(v) {}

  get playbackRate() {}
  set playbackRate(v) {}

  get played() {
    // Screwed since TimeRanges is not constructible.
  }

  get seekable() {
    // Screwed since TimeRanges is not constructible.
  }

  get ended() {
    // https://html.spec.whatwg.org/multipage/embedded-content.html#ended-playback
  }

  get controller() {}
  set controller(v) {}

  get volume() {
    return p(this).volume;
  }
  set volume(v) {
    if (v < 0 || v > 1) {
      // Screwed because DOMException isn't constructible in reality. Per spec it is, but with non-customizable name.
    }
    p(this).volume = v;
    // TODO: actually change the volume.
  }

  get muted() {}
  set muted(v) {}

  get audioTracks() {
    // Screwed since AudioTrackList is not constructible.
  }

  get videoTracks() {
    // Screwed since VideoTrackList is not constructible.
  }

  get textTracks() {
    // Screwed since TextTrackList is not constructible.
  }

  load() {}

  canPlayType(type) {
    // Cannot detect this using web audio, only via the <audio> element -_-
  }

  fastSeek(time) {}

  getStartDate() {}

  play() {}

  pause() {}

  addTextTrack(kind, label, language) {}

  /////

  createdCallback() {
    p.set(this, {
      currentSrc: '',
      networkState: CustomHTMLMediaElement.NETWORK_EMPTY,
      readyState: CustomHTMLMediaElement.HAVE_NOTHING,
      duration: NaN,
      paused: true,
      seeking: false,
      volume: 1.0,
      muted: this.hasAttribute('muted')
    });
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // set or change (not remove) src -> media element load algorithm
  }
}
